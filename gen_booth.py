import argparse

def gen_booth_module(N: int, module_name: str | None = None) -> str:
    assert N >= 2
    M = N + 1  # 扩展位宽

    if module_name is None:
        module_name = f"Booth{N}"

    L: list[str] = []
    L.append("// -----------------------------------------------------------------------------")
    L.append(f"// Auto-generated by gen_booth.py — Booth{N} (Odin-II Safe)")
    L.append("// FIXED: Removed inline concatenation in adder (Segfault trigger).")
    L.append("// FIXED: Correct indexing for Unsigned mode.")
    L.append("// -----------------------------------------------------------------------------")
    L.append(f"module {module_name} (")
    L.append(f"  input  [{N-1}:0] x_in,")
    L.append(f"  input  [{N-1}:0] y_in,")
    L.append( "  input            signed_op,")

    # Outputs: 每行 8 个，防止老旧工具缓冲区溢出
    pp_ports = [f"pp{i}" for i in range(N)]
    for i in range(0, N, 8):
        chunk = pp_ports[i:i+8]
        line_prefix = f"  output [{N-1}:0] "
        L.append(line_prefix + ",  ".join(chunk) + ",")
    
    L.append(f"  output [{N-1}:0] S")
    L.append(");")
    L.append("")

    # 1. 辅助信号 (拆分定义与赋值)
    L.append(f"  wire [{M-1}:0] tmp;")
    L.append(f"  assign tmp = {{y_in, 1'b0}};")
    L.append("")

    # 2. X 扩展 (拆分定义与赋值)
    L.append(f"  wire [{M-1}:0] x_ext;")
    L.append(f"  assign x_ext = {{ (signed_op & x_in[{N-1}]), x_in }};")
    L.append("")
    
    # plus_x
    L.append(f"  wire [{M-1}:0] plus_x;")
    L.append(f"  assign plus_x = x_ext;")
    L.append("")

    # 3. Neg X (关键修复：单独定义常数 1)
    # 旧版本 Odin 在处理 (~x) + {31'b0, 1'b1} 时会段错误
    L.append(f"  wire [{M-1}:0] const_one;")
    L.append(f"  assign const_one = {{ {M-1}'b0, 1'b1 }};")
    
    L.append(f"  wire [{M-1}:0] neg_x;")
    L.append(f"  assign neg_x = (~x_ext) + const_one;")
    L.append("")

    L.append("  // ---------------------------------------------------------------------------")
    L.append("  // Partial Product Generation")
    L.append("  // ---------------------------------------------------------------------------")

    for i in range(N):
        L.append(f"  // Row {i}")
        
        # 别名定义，增加生成的 Verilog 可读性
        y_cur = f"tmp[{i+1}]"  # 当前位 y[i]
        y_prev = f"tmp[{i}]"   # 前一位 y[i-1]

        # === 选择逻辑 ===
        # Unsigned (signed_op=0): 
        #    sel_pos = y_cur
        #    sel_neg = 0
        # Signed (signed_op=1):
        #    sel_pos = (~y_cur & y_prev)  [Booth 01]
        #    sel_neg = (y_cur & ~y_prev)  [Booth 10]
        
        L.append(f"  wire sel_pos{i};")
        L.append(f"  assign sel_pos{i} = signed_op ? (~{y_cur} & {y_prev}) : {y_cur};")
        
        L.append(f"  wire sel_neg{i};")
        L.append(f"  assign sel_neg{i} = signed_op ? ({y_cur} & ~{y_prev}) : 1'b0;")

        # 生成扩展部分积 (M bits)
        # 拆分定义，防止语句过长
        L.append(f"  wire [{M-1}:0] b_pp{i}_ext;")
        L.append(f"  assign b_pp{i}_ext = ({{{M}{{sel_pos{i}}}}} & plus_x) | ({{{M}{{sel_neg{i}}}}} & neg_x);")

        # 输出切片 (N bits)
        L.append(f"  assign pp{i} = b_pp{i}_ext[{N-1}:0];")
        
        # 符号位 S
        # Unsigned 模式下强制为 0
        L.append(f"  assign S[{i}] = signed_op ? b_pp{i}_ext[{N}] : 1'b0;")
        L.append("")

    L.append("endmodule")
    return "\n".join(L)

def main():
    ap = argparse.ArgumentParser(description="Generate Booth (Odin Safe).")
    ap.add_argument("--n", type=int, required=True, help="位宽 N")
    ap.add_argument("--module", type=str, default=None, help="模块名 (默认 Booth{N})")
    ap.add_argument("--out", type=str, default=None, help="输出文件")
    args = ap.parse_args()

    text = gen_booth_module(args.n, args.module)
    if args.out:
        with open(args.out, "w", encoding="utf-8", newline="\n") as f:
            f.write(text)
    else:
        print(text)

if __name__ == "__main__":
    main()